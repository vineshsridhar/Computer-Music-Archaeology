.TH GETMCMD 3  MIDI
.SH NAME
getmcmd, getmcmdb, putmcmd, iputmcmds, putmcmds \- read/write MPU data (MIDI a la Roland MPU-401)
.SH SYNOPSES
.Cs +0
cc ... \-lmidi
#include <midi.h>
.sp
MCMD *getmcmd(fp, now) 
FILE *fp;
long now;
.sp
MCMD *getmcmdb(fp, now, buf, len, statp) 
FILE *fp;
long now;
unsigned char *buf;
int len, *statp;
.sp
long putmcmd(fp, mp) 
FILE *fp;
MCMD *mp;
.sp
iputmcmds(sid, fp, when) 
FILE *fp;
long when;
.sp
long putmcmds(sid, mp) 
MCMD *mp;
.Ce
.SH DESCRIPTION
The following are defined in libmpu.h (included by midi.h):
.Cs
typedef struct  mcmdstr {
	long	when;		/* absolute time, in MPU clocks */
	int	len;		/* length of command stored at cmd */
	unsigned char *cmd;	/* pointer to midi data (no time tag) */
} MCMD;
extern	MCMD	Rt_tcwme;	/* RT_TCWME command */
extern	MCMD	Mpu_nop;	/* MPU_NO_OP command */
extern	MCMD	*getmcmd();	/* read MPU commands */
extern	MCMD	*getmcmdb();	/* getmcmd() with user-supplied buffers */
extern	long	putmcmd();	/* write MPU commands (single stream) */
extern	long	Onow;		/* output clock (single stream) */
extern	long	putmcmds();	/* write MPU commands (multiple stream) */
#define	MAXSID	16		/* max simultaneous output streams */
extern	long	Sonow[MAXSID];	/* output clocks (mult stream) */
.Ce
The call \fIgetmcmd(fp, now)\fP
reads a midi command in MPU-401 format from file descriptor \fIfp\fP
and returns a pointer to an MCMD structure containing it.
The data pointed to by the \fIcmd\fP field are MIDI data,
there are no MPU time tags.
The time tag information is represented by the \fIwhen\fP field which is an
absolute (cumulative) time, measured in MPU clocks.
The \fInow\fP argument specifies the cumulative time (in MPU clocks)
\fIbefore\fP this command is encountered.
Running status bytes are re-inserted in the data returned;
thus programs using getmcmd() need not handle running status.
The only non-MIDI data that appear in the \fIcmd\fP buffer
are the added MPU codes, (RT_TCWME, etc.) which are undefined in the MIDI spec.
RT_TCIP codes do not appear anywhere (are not returned by getmcmd),
but they affect subsequent \fIwhen\fP fields (natch).
.PP
A typical usage of getmcmd() would be:
.Cs
long now = 0L;
while (mp = getmcmd(stdin, now)) {
	now = mp\->when;
	...
}
.Ce
\(rh Beware: Not only is the MCMD structure in static memory, but
the structure's \fIcmd\fP field points to static memory (4096 bytes long);
save both if you are doing simultaneous getmcmd()s.
.PP
The call \fIgetmcmdb(fp, now, buf, len, statp)\fP
is identical to getmcmd(fp, now) except the data is placed in the
buffer \fIbuf\fP (which is \fIlen\fP bytes long) and the current status
byte is saved in the user supplied in *statp.
Thus, multiple simultaneous input streams may be read.
\(rh Beware: As for getmcmd(), the returned MCMD structure is in static memory;
save it if you are doing simultaneous getmcmdb()s.
.PP
On error, getmcmd() and getmcmdb() return \fI(MCMD *) 0\fP.
The possible errors are:
.br
illegal status \- generated by a status byte < 0x80 at a time when running
status has been cleared (e.g. if the file begins with 0x00 0x00 \&. \&. \&.
there's a legal MPU time tag, but an illegal status byte and no history
for running status).
.br
buffer overflow \- returned when the routine encounters a system exclusive
command with too many bytes to fit the buffer.
.br
premature EOF \- EOF was encountered in the middle of a command.
.PP
The call \fIputmcmd(fp, mp)\fP
writes midi command \fI*mp\fP to file descriptor \fIfp\fP.
It returns the current output MPU clock (identical to \fImp\->when\fP).
\fIPutmcmd()\fP maintains its own output clock to calculate time differences.
There are several special argument conventions (a.k.a. ``hacks''):
.Cs
putmcmd((FILE *) 0, mp)	/* set output clock to mp\->when */
putmcmd((FILE *) 0, (MCMD *) 0)	/* set output clock to 0L */
Rt_tcwme.when = now;		/* insert absolute time and */
putmcmd (fp, &Rt_tcwme);	/* write RT_TCWME code */
Mpu_nop.when = now;		/* insert absolute time and */
putmcmd (fp, &Mpu_nop);		/* write MPU_NO_OP code */
.Ce
.PP
The routines \fIiputmcmds()\fP and \fIputmcmds()\fP
allow multiple output streams to have individual output clocks and output
file pointers.  \fIiputmcmds(sid, fp, when)\fP associates an integer identifier
\fIsid\fP with an output clock set to \fIwhen\fP and an output file pointer
\fIfp\fP.  \fIsid\fP must be in the range 0 to \fIMAXSID\fP \- 1.
\fIputmcmds(sid, mp)\fP writes the MCMD *\fImp\fP out to the file pointer associated with \fIsid\fP (Sofp[sid]\fP) and with time tags based on the appropriate
output clock (Sonow[sid]\fP).
Although \fIputmcmds()\fP calls \fIputmcmd()\fP internally,
it does not implement the special argument hacks mentioned
for \fIputmcmd()\fP.
.PP
Both \fIputmcmd()\fP and \fIputmcmds()\fP ignore any MPU events that precede
the time indicated by their output clocks.
Thus, calling \fIiputmcmds(id, fp, 120)\fP effectively shifts the output
forward in time, trimming 120 MPU clocks worth of data from the beginning
of the output.
Both routines will always return the \fIwhen\fP value passed to them, even if
it is smaller than the appropriate output clock, however.
.PP
A final example of using \fIgetmcmd()\fP and \fIputmcmd()\fP to copy a file:
.Cs
long now;
for (now = 0L; mp = getmcmd(stdin, now); now = putmcmd(stdout, mp));
.Ce
.SH SEE ALSO
getsmcmd(3), putamcmd(3)
.SH AUTHOR
Peter Langston, Bell Communications Research (bellcore!psl)
