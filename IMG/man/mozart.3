.TH MOZART 3  "MIDI"
.SH NAME
mozart \- Mozart's ``Musical Dice Game'' data & access routines
.SH SYNOPSIS
.Cs +0
cc ... midi/{sun2|sun3|sun386}/lib/libmidi.a

#include <midi.h>

mozinit(key)

mozgen(buf, s, r, e, chan)
char	*buf;
int	s, r, e, chan;
.Ce

.SH DESCRIPTION
Devised in the late eighteenth century, Wolfgang Amadeus Mozart's
``Musical Dice Game'' gives an algorithm for composing waltzes and
country dances by throwing dice.
These routines implement that scheme, using the original data.
.PP
\fIMozinit(key)\fP defines the key of the piece and
sets up the data for \fImozgen()\fP to use.
It does so destructively, so it should not be called more than once.
.PP
\fIMozgen(buf, s, r, e, chan)\fP generates one bar of music
in the specified buffer and returns the generated byte count.
The \fIs\fP argument specifies which segment of the melody to
output; values of \fIs\fP run from 0 to 15.  Typically, \fIs\fP will
start at 0 and increment to 15.
The \fIr\fP argument is the dice throw.  Legal values are 0 through 10;
these values represent the values generated by a pair of dice [2..12]
minus 2.  A simple expression to generate this value, maintaining the
pair-of-dice distribution, is \fLrand() % 6 + rand() % 6\fP.
The \fIe\fP argument specifies which ending (at the end of the first section)
is to be generated.
The \fIchan\fP argument specifies the MIDI channel for which the output
will be prepared.
.PP
The original instructions require that eight throws of the dice be used to
generate the eight segments of the first part.  These eight segments
are to be played twice (i.e. they should have repeats around them).
Then eight throws generate the segments of the second part.
A simple program to generate a piece with an AAB structure would be:
.Cs
char buf[1024], *bp;
int s;

srand(time(0));
mozinit(0);				/* key of C */
for (bp = buf, s = 0; s < 8; s++)
	bp += mozgen(bp, s, 1, rand() % 6 + rand() % 6, 0);
write(1, buf, bp - buf);		/* A */
write(1, buf, bp - buf);		/* A */
for (bp = buf, s = 8; s < 16; s++)
	bp += mozgen(bp, s, 1, rand() % 6 + rand() % 6, 0);
write(1, buf, bp - buf);		/* B */
.Ce
.PP
Two points are of interest here, the first analytic, the second
historical.
Even a brief perusal of this algorithm shows that at certain places in
the generated piece the outcome is entirely predetermined.
For instance, each piece will have the same ending even though, in the
original manuscript, an attempt was made to disguise this fact.
One can only wonder if this was meant as a joke or a sly manipulation.
Perhaps knowing more about the author would help answer this question.
Which brings us to the second point.  Music historians are not at all
sure that Mozart was responsible for this algorithm; many contend that
it was the work of his publisher instead.
.SH SEE ALSO
IMG(1), ddm(1), ddmt(1)
.SH AUTHOR
Peter Langston, Bell Communications Research (bellcore!psl)
.br
Wolfgang Amadeus Mozart?
